#!/usr/bin/env deno run --allow-run --allow-read --allow-env
import "https://deno.land/x/dotenv/load.ts";

const [sub, ...rest] = Deno.args;
let subcmd = sub || "notes"; // Default to "notes"
let finalArgs = rest;

const psPath = `${import.meta.dirname}/nt.d/${subcmd}.ps1`;
const jsPath = `${import.meta.dirname}/nt.d/${subcmd}.js`;

let command;
let commandArgs;

let psExists = false;
try {
  await Deno.stat(psPath);
  psExists = true;
} catch (e) { if (!(e instanceof Deno.errors.NotFound)) throw e; }

let jsExists = false;
if (!psExists) { // Only check for JS if no PS script found
  try {
    await Deno.stat(jsPath);
    jsExists = true;
  } catch (e) { if (!(e instanceof Deno.errors.NotFound)) throw e; }
}

if (psExists) {
  command = "pwsh";
  commandArgs = ["-NoProfile", "-File", psPath, ...finalArgs];
} else if (jsExists) {
  command = "deno";
  commandArgs = ["run", "--allow-all", jsPath, ...finalArgs];
} else {
  // Fallback to notes.js if no matching script found
  const fallbackNotesPath = `${import.meta.dirname}/nt.d/notes.js`;
  command = "deno";
  // Pass the original subcmd as an argument to notes.js for catch-all behavior
  commandArgs = ["run", "--allow-all", fallbackNotesPath, sub, ...rest];
}

const cmd = new Deno.Command(command, {
  args: commandArgs,
  stdin: "inherit",
  stdout: "inherit",
  stderr: "inherit"
});

const child = cmd.spawn();
const status = await child.status;
Deno.exit(status.code);
