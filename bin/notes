#!/usr/bin/env deno run --allow-net --allow-env --allow-read
import { Command } from "https://deno.land/x/cliffy@v1.0.0-rc.4/command/mod.ts";
import Task from "https://esm.sh/data.task";

const isPiped = !Deno.isatty(Deno.stdin.rid);

const NOTES_ENDPOINT = Deno.env.get('NOTES_ENDPOINT') || '';
const NOTES_TOKEN = Deno.env.get('NOTES_TOKEN') || '';
const NOTES_DIR = Deno.env.get('NOTES_DIR') || '';

function all (tasks) {
  if (!Array.isArray(tasks) || tasks.length === 0) {
    return Task.of([]);
  }

  return new Task((reject, resolve) => {
    const results = new Array(tasks.length);
    let completed = 0;
    let hasRejected = false;
    const cleanups = [];

    // Handle individual task completion
    const handleComplete = (index, result) => {
      if (hasRejected) return;

      results[index] = result;
      completed++;

      if (completed === tasks.length) {
        resolve(results);
      }
    };

    // Handle individual task rejection
    const handleReject = (error) => {
      if (hasRejected) return;

      hasRejected = true;
      reject(error);

      // Clean up all remaining tasks
      cleanups.forEach(cleanup => cleanup && cleanup());
    };

    // Fork all tasks
    tasks.forEach((task, index) => {
      const cleanup = task.fork(
        (error) => handleReject(error),
        (result) => handleComplete(index, result)
      );
      cleanups.push(cleanup);
    });

    // Return cleanup function
    return () => {
      hasRejected = true;
      cleanups.forEach(cleanup => cleanup && cleanup());
    };
  });
};

function juxt(...fns){
  return function(x){
    return Task.all(fns.reduce(function(memo, f){
      memo.push(f(x));
      return memo;
    }, []));
  }
}

Task.all = all;
Task.juxt = juxt;

const jnl = /^\d{4}-\d{2}-\d{2}\s(?:Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday)$/;

function toInt(s) {
  return typeof s === 'string' && /^-?\d+$/.test(s) ? Number(s) : null
}

async function getNormalizedName(name){
  const page = await callLogseq('logseq.Editor.getPage', [toInt(name) || name]);
  return page?.originalName;
}

async function isJournal(name){
  const page = await callLogseq('logseq.Editor.getPage', [name]);
  if (!page) return false;
  const { ['journal?']: journal } = page;
  return journal;
}

async function exists(path){
  try {
    await Deno.stat(path);
    return path
  } catch (error) {
    return null;
  }
}

function encode(name){
  return name ? encodeURIComponent(name).replaceAll("%20", " ") : null;
}

async function getFilePath(journal, name){
  const where = journal ? "journals" : "pages";
  const normalized = journal ? name.replaceAll("-", "_").split(" ")?.[0].trim() : encode(name.replaceAll("/", ".").trim());
  return await exists(`${NOTES_DIR}/${where}/${normalized}.md`);
}

const je = /^(?:\d{8}|\d{4}-\d{2}-\d{2})$/;

async function getJournalPage(datestamp){
  const arg = datestamp.split(' ')?.[0].replaceAll("-", "");
  const result = await promise(qry(`[:find (pull ?p [*]) :where [?p :block/journal-day ${arg}]]`));
  const obj = result?.[0]?.[0] || {};
  return obj["journal?"] ? obj["original-name"] : null;
}

async function getNames(given){
  if (!given) return null;
  const named = je.test(given) ? await getJournalPage(given) : given;
  const normalized = await getNormalizedName(named);
  const alias = normalized ? await aka(normalized) : null;
  const name = alias || normalized || given; // fallback to given if normalized is null
  const journal = name ? await isJournal(name) : null;
  const path = name ? await getFilePath(journal, name) : null;
  const names = {given, journal, normalized, name, path};
  //console.log({names});
  return names;
}

async function callLogseq(method, args) {
  const payload = { method }
  if (args) {
    payload.args = args
  }

  const response = await fetch(NOTES_ENDPOINT, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${NOTES_TOKEN}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(payload),
  })

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`)
  }

  const result = await response.json()

  if (result && result.error) {
    throw new Error(result.error)
  }

  return result
}

async function collectPrerequisites(startName) {

  const seen = new Set();
  const result = [];

  async function dfs(startName) {
    const names = await getNames(startName);
    const {name} = names;

    if (seen.has(name)) return;          // dedupe + short-circuit

    seen.add(name);
    result.push(name);                   // keep "first name comes up top" order

    const results = await promise(qry(`[:find (pull ?p [:block/properties :block/original-name]) :where [?p :block/original-name "${name}"]]`));
    const prereqs = results?.[0]?.[0]?.properties?.prerequisites || [];
    for (const prereqName of prereqs) {
      await dfs(prereqName);             // nesting until leaf nodes
    }
  }

  await dfs(startName);
  return result;
}

function promise(tsk){
  return new Promise(function(resolve, reject){
    tsk.fork(reject, resolve);
  });
}

function forkable(g){
  return async function (options, ...payload){
    const f = g(options);
    if (isPiped){
      await piped(async function(arg){
        await promise(f(arg, ...payload)).catch(balk).then(println);
      });
    } else {
      await promise(f(...payload)).catch(balk).then(println);
    }
    Deno.exit(0);
  }
}

async function piped(f){
  const decoder = new TextDecoder()
  let stdinContent = ''
  const buffer = new Uint8Array(1024)

  while (true) {
    const n = await Deno.stdin.read(buffer)
    if (n === null) {
      break
    }
    stdinContent += decoder.decode(buffer.subarray(0, n))
  }

  if (stdinContent === '') {
    throw new Error('No inputs')
  }

  const lines = stdinContent.split('\n')
    .map(line => line.trim())
    .filter(line => line.length > 0);

  for (const line of lines) {
    await f(line);
  }
}

function pipeable(g){
  return async function (options, ...payload){
    const f = g(options);
    if (isPiped){
      await piped(function(arg){
        return f(arg, ...payload);
      });
    } else {
      await f(...payload);
    }
  }
}

// Recursive filtering function for blocks
function selectBlock(block, keep) {
  const {content, properties} = block;

  // Test content with and without marker to catch both cases
  const kept = keep(content);

  if (!kept) {
    return null;
  }

  let filteredChildren = [];
  if (block.children && Array.isArray(block.children)) {
    filteredChildren = block.children
      .map(child => selectBlock(child, keep))
      .filter(child => child !== null); // Remove null entries (filtered out children)
  }

  // If this block doesn't have meaningful content and all children were filtered out, filter this block too
  const hasContent = content || null;
  const hasProperties = properties && Object.keys(properties).length > 0;
  const hasMeaningfulContent = hasContent || hasProperties;

  if (!hasMeaningfulContent && filteredChildren.length === 0) {
    return null; // This block has no meaningful content and no children after filtering
  }

  // Keep this block (it doesn't match any patterns)
  return {
    ...block,
    children: filteredChildren
  };
}

// Helper function to convert nested JSON back to markdown format
function nestedJsonToMarkdown(blocks, level = 0) {
  const lines = [];
  const indent = '  '.repeat(level);
  const hanging = '  '.repeat(level + 1);

  blocks.forEach(function(block) {
    const {content, children} = block;
    if (content) {
      const [line, ...parts] = content.split("\n");
      if (line.includes("::")) {
        lines.push(`${indent}${line}`);
        for(const line of parts){
          lines.push(`${indent}${line}`);
        }
      } else {
        lines.push(`${indent}- ${line}`);
        for(const line of parts){
          if (!line.startsWith("collapsed:: ")) {
            lines.push(`${hanging}${line}`);
          }
        }
      }
    }

    if (children && children.length > 0) {
      lines.push(...nestedJsonToMarkdown(children, level + 1));
    }
  });

  return lines;
}

function keeping(patterns, hit = true){
  const miss = !hit;
  const regexes = (patterns || []).map(pattern => new RegExp(pattern));
  return regexes.length ? function(text){
    for(const re of regexes) {
      if (re.test(text)) {
        return hit;
      }
    }
    return miss;
  } : null
}

function page(options){
  const format = options.json ? 'json' : (options.format || 'md');
  const append = options.append || null;
  const heading = options.heading !== false;
  const nest = options.nest || false;
  const keep = keeping(options.less, false) || keeping(options.only, true);

  return async function(named){
    try {
      const names = await getNames(named);
      if (!names) {
        throw new Error(`Page not found: ${named}`);
      }

      const {name, path} = names;

      // Handle append case early - it bypasses all processing
      if (append) {
        if (!name) {
          throw new Error('--append option requires a page name to be provided');
        }
        await callLogseq('logseq.Editor.appendBlockInPage', [name, append]);
        return;
      }

      // STAGE 1: Exception case - Simple MD format without nest and without filter
      // Bypass all processing and just print the page directly from file
      if (format === 'md' && !nest && keep == null) {
        if (!path) {
          return;
        }

        try {
          const content = (await Deno.readTextFile(path)).replace(/\s+$/, '');

          if (heading && content) {
            console.log(`# ${name}`);
          }
          console.log(content + (heading ? "\n" : ""));
        } catch (fileError) {
          console.error(`Warning: Could not read page file: ${path} (${fileError.message})`);
        }
        return;
      }

      // STAGE 2: Common Data Gathering
      // Gather all data into a common structure
      let data;

      const result = await callLogseq('logseq.Editor.getPageBlocksTree', [name]);

      data = result || [];

      // STAGE 3: Unified Filtering
      // Apply filters if any are provided (regardless of nest)
      if (keep) {
        // Always use hierarchical filtering since API returns hierarchical data
        data = data
          .map(block => selectBlock(block, keep))
          .filter(block => block !== null);
      }

      // STAGE 4: Unified Format Output
      if (format === 'json') {
        // Output data as JSON
        console.log(JSON.stringify(data, null, 2));
      } else if (format === 'md') {
        if (heading) {
          console.log(`# ${name}`);
        }
        const markdownLines = nestedJsonToMarkdown(data);
        if (markdownLines.length > 0) {
          console.log(markdownLines.join('\n'));
        }
        if (heading) {
          console.log();
        }
      } else {
        throw new Error(`Unknown format: ${format}`);
      }
    } catch (error) {
      console.error('Error:', error.message);
      Deno.exit(1);
    }
  }
}

function search(options){
  const format = options.json ? 'json' : (options.format || 'md')
  return async function (term) {
    try {
      const result = await callLogseq('logseq.Editor.search', [term])
      if (format === 'json') {
        console.log(JSON.stringify(result, null, 2))
      } else if (format === 'md') {
        // Extract page IDs; use uniqueness to minimize lookups
        const pageIds = new Set()
        result?.
          blocks?.
          map(block => block['block/page']).
          forEach(id => pageIds.add(id));

        const promisedNames =
          Array.from(pageIds).
            map(async function(id){
              try {
                const pageResult = await callLogseq('logseq.Editor.getPage', [id]);
                return pageResult?.originalName;
              } catch (ex) {
                console.error(`Warning: Could not get page ${id}: ${ex.message}`);
                return null;
              }
            });

        const names = (await Promise.all(promisedNames)).
          filter(Boolean).
          forEach(name => console.log(name));
      } else {
        throw new Error(`Unknown format: ${format}`);
      }
    } catch (error) {
      console.error('Error:', error.message);
      Deno.exit(1);
    }
  }
}

function path(){
  return function(name){
    return tskNames(name).
      map(({path}) => path);
  }
}

function prereq(){
  return async function (name){
    try {
      if (!name) {
        console.error('Error: Name argument is required');
        console.error('Usage: notes prereq <name>');
        Deno.exit(1);
      }

      const results = await collectPrerequisites(name);
      results.forEach(name => console.log(name));
      // Return results instead of directly outputting them
      return results;
    } catch (error) {
      console.error('Error:', error.message);
      Deno.exit(1);
    }
  }
}

function named(options){
  const format = options.json ? 'json' : (options.format || 'md')
  return async function(id){
    try {
      let result = await callLogseq('logseq.Editor.getPage', [id]);

      // If direct lookup failed and id looks like a number, try to find page by searching all pages
      if (!result && /^\d+$/.test(id)) {
        try {
          // Get all pages and find the one with matching numeric ID
          const allPages = await callLogseq('logseq.Editor.getAllPages')
          const matchingPage = allPages.find(page => page.id.toString() === id)
          if (matchingPage) {
            result = matchingPage
          }
        } catch (searchError) {
          // If search fails, continue with null result
        }
      }

      if (format === 'json') {
        console.log(JSON.stringify(result, null, 2))
      } else if (format === 'md') {
        if (result && result.originalName) {
          console.log(result.originalName);
        }
        // If no page is found, output nothing (just exit silently)
      } else {
        throw new Error(`Unknown format: ${format}`);
      }
    } catch (error) {
      console.error('Error:', error.message);
      Deno.exit(1);
    }
  }
}

function tags(options){
  return has(options, "tags");
}

function alias(options){
  return has(options, "alias");
}

async function aka(...args){
  const result = await alias({format: "md", silent: true})(...args);
  return result?.[0];
}

function qryProps(prop, vals, mode = "any"){
  return new Task(function(reject, resolve){
    if (!['any', 'all'].includes(mode)){
      reject(new Error(`Mode must be "any" or "all" and was "${mode}".`));
    }
    const conditions = vals.map(val => `[(contains? ?prop "${val}")]`).join(' ');
    const whereClause = mode === 'any' ? `(or ${conditions})` : conditions;
    return qry(`[:find (pull ?page [:block/original-name])
                    :where
                    [?page :block/properties ?props]
                    [(get ?props :${prop}) ?prop]
                    ${whereClause}]`).
      fork(reject, function(results){
        const names = results.map(function([item]){
          return item?.["original-name"];
        }).filter(name => name);
        resolve(names);
      });
  })
}

function has(options, prop = null){
  // Validate mutually exclusive options
  if (options.all && options.any) {
    throw new Error('--all and --any options are mutually exclusive');
  }

  const format = options.json ? 'json' : (options.format || 'md');
  const mode = options.any ? 'any' : 'all'; // Default to 'all'
  const fn = async function(prop, ...vals){
    try {
      if (vals.length === 0) {
        throw new Error('At least one prop value is required');
      }

      const result = await promise(qryProps(prop, vals, mode));

      if (format === 'json') {
        return result;
      } else if (format === 'md') {
        return result;
      } else {
        throw new Error(`Unknown format: ${format}`);
      }
    } catch (error) {
      console.error('Error:', error.message);
      Deno.exit(1);
    }
  }

  const exec = prop ? fn.bind(null, prop) : fn;

  return async function(...args){
    const {silent, format = "md"} = options;
    //console.log({silent, options, args})
    const result = await exec(...args);
    if (!silent) {
      if (format == "md") {
        result.forEach(name => console.log(name));
      } else {
        console.log(JSON.stringify(result, null, 2))
      }
    }
    return result;
  }
}

const take = (xs, n = Infinity) =>
  Array.isArray(xs) ? xs.slice(0, n) : [];

function backlinks(options){
  const format = options.json ? 'json' : (options.format || 'md');
  const limit = options.limit ? parseInt(options.limit) : Infinity;
  return async function(pageName){
    try {
      if (!pageName) {
        throw new Error('Page name is required');
      }

      const items = await promise(qry(`[:find (pull ?b [:block/content :block/page]) :where [?b :block/path-refs ?p] [?p :block/name "${pageName.toLowerCase()}"]]`, limit));

      if (format === 'json') {
        console.log(JSON.stringify(items, null, 2));
      } else {
        // Extract unique page IDs from backlink results
        const pageIds = new Set()
        items?.forEach(item => {
          const block = item?.[0];
          if (block?.page?.id) {
            pageIds.add(block.page.id);
          }
        });

        // Get page details for each unique page ID
        const pageNames = new Set()
        for (const pageId of pageIds) {
          try {
            const pageResult = await callLogseq('logseq.Editor.getPage', [pageId])
            if (pageResult && pageResult.originalName) {
              pageNames.add(pageResult.originalName);
            }
          } catch (pageError) {
            // Continue with other pages if one fails
            console.error(`Warning: Could not get page ${pageId}: ${pageError.message}`);
          }
        }

        // Output deduplicated page names (one per line)
        pageNames.forEach(name => console.log(name));
      }
    } catch (error) {
      console.error('Error:', error.message);
      Deno.exit(1);
    }
  }
}

function query(options){
  const format = options.json ? 'json' : (options.format || 'md');
  const limit = options.limit ? parseInt(options.limit) : Infinity;
  return async function(query){
    try {
      if (!query) {
        throw new Error('No query provided');
      }

      const items = await promise(qry(query, limit));

      if (format == "json") {
        console.log(JSON.stringify(items, null, 2));
      } else {
        items.
          map(item => item?.[0]).
          map(content => content["replace"] ? content?.replace("\ncollapsed:: true", "")?.replace("\ncollapsed:: false") : content).
          forEach(item => console.log(item));
      }
    } catch (error) {
      console.error('Error:', error.message);
      Deno.exit(1);
    }
  }
}

const comp = (...fns) => (arg) => fns.reduceRight((acc, fn) => fn(acc), arg);

function normalizeOptions(options){
  const format = options.json ? 'json' : (options.format || 'md');
  const heading = options.heading !== false;
  return {format, heading}
}

function qry(query, limit = Infinity){
  return new Task(function(reject, resolve){
    callLogseq('logseq.DB.datascriptQuery', [query]).then(function(results){
      return take(results , limit);
    }).then(resolve).catch(reject);
  });
}

function qryPage(name){
  return qry(`[:find (pull ?p [*]) :where [?p :block/original-name "${name}"]]`);
}

function tskNames(name){
  return name ? new Task(function(reject, resolve){
    getNames(name).then(function(names){
      if (names?.name) {
        resolve(names);
      } else {
        reject(new Error(`Page not found: ${name}`));
      }
    }).catch(reject);
  }) : Task.rejected(new Error('Page name is required'));
}

function normal(name){
  return tskNames(name).map(({name}) => name);
}

function fmtProps({format}, propName = null){
  return function([name, results]){
    //console.log({results, propName});
    const pageData = results[0]?.[0] || null;

    if (format === 'json') {
      if (pageData) {
        return [name, JSON.stringify(results, null, 2)];
      }
    } else if (format === 'md') {
      return [name, propName ? pageData?.properties?.[propName] || null : Object.entries(pageData["properties-text-values"]).map(function([key, vals]){
        return `${key}:: ${vals}`;
      })];
    } else {
      throw new Error(`Unknown format: ${format}`);
    }
  }
}

function fmtBody({heading, format}){
  return function([name, content]){
    //console.log({name, content})
    if (format === 'json') {
      return [name, JSON.stringify(content, null, 2)];
    } else if (format === 'md') {
      const lines = [];
      if (heading && name && content) {
        lines.push(`## ${name}`);
      }
      if (content) {
        typeof content == 'object' ? lines.push(...content) : lines.push(content);
      }
      if (heading && name && content) {
        lines.push("");
      }
      return lines;
    }
  }
}

function balk(error){
  console.error('Error:', error.message);
  Deno.exit(1);
}

function println(lines){
  Array.isArray(lines) ? lines.forEach(line => console.log(line)) : console.log(lines);
}

function props(options){
  return function(pageName, propName = null){
    return normal(pageName).
      chain(Task.juxt(Task.of, qryPage)).
      map(fmtProps(options, propName)).
      map(fmtBody(options));
  }
}

//TODO handle `notes props Assisting` with or without piping
function demand(...whats){
  return /*isPiped ?*/ whats.map(what => `[${what}]`).join(' ') /*: whats.map(what => `<${what}>`).join(' ')*/;
}

//qryProps("tags", ["Employing Agents"]).fork(balk, println);

const program = new Command()
  .name('notes')
  .description('Access and append to pages and journals')
  .version('1.0.0')
  .stopEarly();

program
  .command('pages')
  .description('List pages')
  .option('-t, --type <type:string>', 'Page type (regular|journal|all)', 'regular')
  .option('-f, --format <type:string>', 'Output format (md|json) (default: "md")', 'md')
  .option('--json', 'Output JSON format')
  .action(async (options) => {
    try {
      const format = options.json ? 'json' : (options.format || 'md');
      const type = options.type || 'regular';
      const results = await callLogseq('logseq.Editor.getAllPages');
      const selected = type == 'all' ? results : type == "journal" ? results.filter(item => !!item["journal?"]) : results.filter(item => !item["journal?"]);
      if (format === 'json') {
        console.log(JSON.stringify(selected, null, 2))
      } else if (format === 'md') {
        selected.map(item => item.originalName).forEach(name => console.log(name));
      } else {
        throw new Error(`Unknown format: ${format}`)
      }
    } catch (error) {
      console.error('Error:', error.message)
      Deno.exit(1)
    }
  });

program
  .command('page')
  .alias('p')
  .description("Get page")
  .arguments(demand("name|datestamp"))
  .option('-f, --format <type:string>', 'Output format (md|json) (default: "md")', 'md')
  .option('--json', 'Output JSON format')
  .option('--no-heading', 'Omit H1 heading and trailing blank line for MD format')
  .option('-a, --append <content:string>', 'Append content to page')
  .option('--nest', 'Use hierarchical nesting with format output')
  .option('-l, --less <patterns:string>', 'Less content matching regex patterns', { collect: true })
  .option('-o, --only <patterns:string>', 'Only content matching regex patterns', { collect: true })
  .action(pipeable(page));

program
  .command('tags')
  .alias('t')
  .description('List pages with given tags (default: ALL tags)')
  .arguments(demand("tags..."))
  .option('--all', 'Require ALL tags to be present (default)')
  .option('--any', 'Require ANY tag to be present')
  .option('-f, --format <type:string>', 'Output format (md|json) (default: "md")', 'md')
  .option('--json', 'Output JSON format')
  .action(pipeable(tags));

program
  .command('has')
  .alias('h')
  .description('List pages having a given prop with value(s)')
  .arguments(demand("prop", "vals..."))
  .option('--all', 'Require ALL tags to be present (default)')
  .option('--any', 'Require ANY tag to be present')
  .option('-f, --format <type:string>', 'Output format (md|json) (default: "md")', 'md')
  .option('--json', 'Output JSON format')
  .action(pipeable(has));

program
  .command('prereq')
  .description('Recursively list page prerequisites')
  .arguments(demand("name"))
  .action(pipeable(prereq));

program
  .command('path')
  .description('The path to the page file')
  .arguments(demand("name"))
  .action(forkable(path));

program
  .command('props')
  .description('Get page properties')
  .arguments(demand("name", "property"))
  .option('-f, --format <type:string>', 'Output format (md|json) (default: "md")', 'md')
  .option('--desc', "With description")
  .option('--json', 'Output JSON format')
  .option('--no-heading', 'Omit H1 heading and trailing blank line for MD format')
  .action(forkable(comp(props, normalizeOptions)));

program
  .command('search')
  .alias('s')
  .description('Search pages')
  .arguments(demand("term"))
  .option('-f, --format <type:string>', 'Output format (md|json) (default: "md")', 'md')
  .option('--json', 'Output JSON format')
  .action(pipeable(search));

program
  .command('name')
  .alias('n')
  .description('Get page name from ID or normalized name from name')
  .arguments(demand("id|name"))
  .option('-f, --format <type:string>', 'Output format (md|json) (default: "md")', 'md')
  .option('--json', 'Output JSON format')
  .action(pipeable(named));

program
  .command('alias')
  .alias('a')
  .description('Get page name from alias')
  .arguments(demand("alias"))
  .action(pipeable(alias));

program
  .command('backlinks')
  .alias('b')
  .description('List pages that link to a given page')
  .arguments(demand("name"))
  .option('--limit <type:string>', 'Limit to N entries (none = no limit) (default: "none")', 'none')
  .option('-f, --format <type:string>', 'Output format (md|json) (default: "md")', 'md')
  .option('--json', 'Output JSON format')
  .action(pipeable(backlinks));

program
  .command('query')
  .alias('q')
  .description('Execute Datalog query')
  .arguments(demand("query"))
  .option('--limit <type:string>', 'Limit to N entries (none = no limit) (default: "none")', 'none')
  .option('-f, --format <type:string>', 'Output format (md|json) (default: "md")', 'md')
  .option('--json', 'Output JSON format')
  .action(pipeable(query));

if (import.meta.main) {
  if (Deno.args.length === 0) {
    program.showHelp();
    Deno.exit(0);
  }
  await program.parse();
}
